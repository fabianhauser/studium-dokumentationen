\input{../template.tex}

\title{Zusammenfassung AD1}
\author{Fabian Hauser}
 
\begin{document}
\maketitle


Software soll, \emph{Robust}, \emph{Adaptierbar} und \emph{Wiederverwendbar} sein, was via \emph{Abstraktion}, \emph{Kapselung} und \emph{Modularität} erreicht werden soll.

\section{Datenstrukturen}
\subsection{Arrays}

Arrays sind Container-Objekte, und enthalten im Java immer nur Referenzen auf gleichartige Objekte.

\paragraph{Vorteile}
\begin{itemize}
	\item Schneller Random Access (immer gleich lang)
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
	\item Kann nicht einfach vergrössert werden (umkopieren nötig)
	\item Einfügen, Löschen \& Sortieren aufwändig.
\end{itemize}

\subsection{LinkedList}

\includegraphics[scale=0.3]{img/linkedlist.png} \\
Nutzt Rekursion (Referenz auf eigenen Typen) zum feststellen des jeweilig nächsten Elements

\paragraph{Vorteile}
\begin{itemize}
	\item Entfernen eines Knotens immer gleich (einfach)
	\item Einfügen eines Knotens immer gleich (einfach)
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
	\item Random Access braucht lange (iterieren durch alle Elemente)
	\item Nicht Thread-sicher (\emph{Collections.synchronizedList(new LinkedList(...))})
\end{itemize}

\subsubsection{Doubly-Linked-List}

Es wird jeweils auch das Previous-Element referenziert; Vorteil: es können Elemente von beiden Enden schnell abgeholt werden.

\subsubsection{Circularly-Linked-Lists}

Zirkuläre Listen, d.h., das letzte Element ist mit dem ersten verknüpft. es gibt jeweils einen Cursor auf das aktuelle Element.

for(int[] currencyUnit : currencyUnits)   


\subsection{Pseudocode}
\includegraphics[scale=0.3]{img/pseudocode.png}

\subsection{Laufzeitverhalten}

\subsubsection{Zeitliche Funktionen}
\begin{itemize}
	\item konstant $\approx 1$
	\item logarithmisch $\approx \log n$
	\item linear $\approx  n$
	\item N-Log-N $\approx n \log n$
	\item quadratisch $\approx n^2$
	\item qubisch $\approx n^3$
	\item exponentiell $\approx 2^n$
\end{itemize}

\subsubsection{Big-Oh Notation}
 
Berechnung der Präfixe: Herausfinden, wie oft eine Operation in einem Algorithmus durchläuft; dabei ist nur essentiell, ob $n$, $n^2$ etc. Durchläufe stattgefunden haben.

Beispiel: $O(n^2)$

\subsubsection{Big-Omega, Big-Theta}

\includegraphics[scale=0.3]{img/verwandte-big-oh.png}

\subsubsection{Vergleich Big-Oh, Omega, Theta}

\includegraphics[scale=0.3]{img/big-oh-vergleich.png}

\subsection{Rekursion}

Braucht:
\begin{itemize}
	\item Verankerung / base case(s): Ende des Rekursiven Aufrufes / Abbruchbedingung
	\item Methode ruft sich selber auf, bringt den Zustand näher an die Verankerung.
\end{itemize}

\subsubsection{Lineare Rekursion}

\subsubsection{Binäre Rekursion}

\subsubsection{Andere Rekursion}



\section{Patternator}

\subsection{Adapter}
\subsubsection{Objectadapter}

Besser für Sicherheit

Implementation via Klassenvariable

\subsubsection{Classadapter}

Einfacher/Flexibel

Implementation Interface


\end{document}